import numpy as np
import matplotlib.pyplot as plt
# d. Use python, and write a function which takes N = 2000
# and generates N observations from the distribution.
def generate_observations(N=2000):
# Generate N uniform random variables in [0, 1]
U = np.random.uniform(0, 1, N)
# Apply the inverse CDF formula to generate X
X = (1 / (1 - U)**2) - 1
return X
# Generate 2000 observations
N = 2000
observations = generate_observations(N)
# Filter data to remove extreme outliers for better visualization
# filtered_observations = observations[observations < 50]  # Focus on values below 50 for clarity
# Plot the histogram of the generated data
plt.hist(observations, bins=50, density=True, alpha=0.6, label='Generated Data')
# Define the original PDF function
def pdf(x):
return 1 / (2 * (1 + x)**1.5)
# Generate x values for plotting the PDF
x_vals = np.linspace(0, 100, 1000)  # Limit x-axis to match the filtered data
y_vals = pdf(x_vals)
# Plot the PDF on top of the histogram
plt.plot(x_vals, y_vals, 'r-', linewidth=2, label='PDF f(x)')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Histogram of Generated Data and PDF')
plt.legend()
plt.show()
import numpy as np
import matplotlib.pyplot as plt
# d. Use python, and write a function which takes N = 2000
# and generates N observations from the distribution.
def generate_observations(N=2000):
# Generate N uniform random variables in [0, 1]
U = np.random.uniform(0, 1, N)
# Apply the inverse CDF formula to generate X
X = (1 / (1 - U)**2) - 1
return X
# Generate 2000 observations
N = 2000
observations = generate_observations(N)
# Filter data to remove extreme outliers for better visualization
# filtered_observations = observations[observations < 50]  # Focus on values below 50 for clarity
# Plot the histogram of the generated data
plt.hist(observations, bins=50, density=True, alpha=0.6, label='Generated Data')
# Define the original PDF function
def pdf(x):
return 1 / (2 * (1 + x)**1.5)
# Generate x values for plotting the PDF
x_vals = np.linspace(0, 100, 500)  # Limit x-axis to match the filtered data
y_vals = pdf(x_vals)
# Plot the PDF on top of the histogram
plt.plot(x_vals, y_vals, 'r-', linewidth=2, label='PDF f(x)')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Histogram of Generated Data and PDF')
plt.legend()
plt.show()
import numpy as np
import matplotlib.pyplot as plt
# d. Use python, and write a function which takes N = 2000
# and generates N observations from the distribution.
def generate_observations(N=2000):
# Generate N uniform random variables in [0, 1]
U = np.random.uniform(0, 1, N)
# Apply the inverse CDF formula to generate X
X = (1 / (1 - U)**2) - 1
return X
# Generate 2000 observations
N = 2000
observations = generate_observations(N)
# Filter data to remove extreme outliers for better visualization
# filtered_observations = observations[observations < 50]  # Focus on values below 50 for clarity
# Plot the histogram of the generated data
plt.hist(observations, bins=50, density=True, alpha=0.6, label='Generated Data')
# Define the original PDF function
def pdf(x):
return 1 / (2 * (1 + x)**1.5)
# Generate x values for plotting the PDF
x_vals = np.linspace(0, 100, 100)  # Limit x-axis to match the filtered data
y_vals = pdf(x_vals)
# Plot the PDF on top of the histogram
plt.plot(x_vals, y_vals, 'r-', linewidth=2, label='PDF f(x)')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Histogram of Generated Data and PDF')
plt.legend()
plt.show()
import numpy as np
import matplotlib.pyplot as plt
# d. Use python, and write a function which takes N = 2000
# and generates N observations from the distribution.
def generate_observations(N=2000):
# Generate N uniform random variables in [0, 1]
U = np.random.uniform(0, 1, N)
# Apply the inverse CDF formula to generate X
X = (1 / (1 - U)**2) - 1
return X
# Generate 2000 observations
N = 2000
observations = generate_observations(N)
# Filter data to remove extreme outliers for better visualization
# filtered_observations = observations[observations < 50]  # Focus on values below 50 for clarity
# Plot the histogram of the generated data
plt.hist(observations, bins=50, density=True, alpha=0.6, label='Generated Data')
# Define the original PDF function
def pdf(x):
return 1 / (2 * (1 + x)**1.5)
# Generate x values for plotting the PDF
x_vals = np.linspace(0, 1000, 100)  # Limit x-axis to match the filtered data
y_vals = pdf(x_vals)
# Plot the PDF on top of the histogram
plt.plot(x_vals, y_vals, 'r-', linewidth=2, label='PDF f(x)')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Histogram of Generated Data and PDF')
plt.legend()
plt.show()
import numpy as np
import matplotlib.pyplot as plt
# d. Use python, and write a function which takes N = 2000
# and generates N observations from the distribution.
def generate_observations(N=2000):
# Generate N uniform random variables in [0, 1]
U = np.random.uniform(0, 1, N)
# Apply the inverse CDF formula to generate X
X = (1 / (1 - U)**2) - 1
return X
# Generate 2000 observations
N = 2000
observations = generate_observations(N)
# Plot the histogram of the generated data
plt.hist(observations, bins=50, density=True, alpha=0.6, label='Generated Data')
# Define the original PDF function
def pdf(x):
return 1 / (2 * (1 + x)**1.5)
# Generate x values for plotting the PDF
x_vals = np.linspace(0, 1000, 100)  # Limit x-axis to match the filtered data
y_vals = pdf(x_vals)
# Plot the PDF on top of the histogram
plt.plot(x_vals, y_vals, 'r-', linewidth=2, label='PDF f(x)')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Histogram of Generated Data and PDF')
plt.legend()
plt.show()
reticulate::repl_python()
# Install and load the reticulate package
if (!requireNamespace("reticulate", quietly = TRUE)) {
install.packages("reticulate")
}
library(reticulate)
py_install("seaborn")
reticulate::repl_python()
# Load the necessary library
library(ggplot2)
# Load the dataset
dataset <- read.csv("diamonds.csv")
# a. Focus on the diamond observations whose carat is greater
# than 0.5 and whose price is less than 5000.
filtered_data <- subset(dataset, carat > 0.5 & price < 5000)
head(filtered_data).
# Load the necessary library
library(ggplot2)
# Load the dataset
dataset <- read.csv("diamonds.csv")
# a. Focus on the diamond observations whose carat is greater
# than 0.5 and whose price is less than 5000.
filtered_data <- subset(dataset, carat > 0.5 & price < 5000)
head(filtered_data)
# b. Use ggplot and study the relationship between the two
# variables of price and carat from part (a) data. Explain
# which graphical display should be used and why.
ggplot(filtered_data, aes(x = carat, y = price,)) +
geom_point() +
ggtitle("Price vs Carat (Filtered)") +
xlab("Carat") +
ylab("Price")
# The scatterplot is used here because it effectively shows
# the relationship between two continuous variables price and carat.
# c. Facet the plot by ‘cut‘ so that each facet corresponds
# to a diﬀerent diamond cut.
# Facet by cut
ggplot(filtered_data, aes(x = carat, y = price)) +
geom_point() +
facet_wrap(~ cut) +
ggtitle("Price vs Carat Faceted by Cut") +
xlab("Carat") +
ylab("Price")
# d) Color the points by ‘clarity‘. Carefully add the labels
# for the x-axis, y-axis, title and legend.
ggplot(filtered_data, aes(x = carat, y = price, color = clarity)) +
geom_point() +
facet_wrap(~ cut) +
ggtitle("Price vs Carat Faceted by Cut and Colored by Clarity") +
xlab("Carat") +
ylab("Price") +
theme(legend.title = element_text(size = 10))
